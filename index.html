<!doctype html>
<html lang="">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Redirecting to Waystation Web...</title>
  <meta name="description" content="">
  <meta http-equiv="refresh" content="0; url=/web">

  <meta property="og:title" content="">
  <meta property="og:type" content="">
  <meta property="og:url" content="">
  <meta property="og:image" content="">
  <meta property="og:image:alt" content="">

  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" href="/icon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="icon.png">

  <script>
    // Fallback redirect if meta refresh doesn't work
    window.location.href = '/web';
  </script>
</head>

<body>
  <p>Redirecting to Waystation Web...</p>
  <p>If you are not redirected, <a href="/web">click here</a>.</p>

  <!-- VSCode extension version is at /vscode (if needed) -->

<script>
// Keep original mock data for backward compatibility
window.__INITIAL_DATA__ = {
  flows: [
  {
    "id": "a04b3b6c-1d48-44bb-9ce4-2b955ef7b792",
    "name": "PR: new state management setup",
    "description": "A _very_ *nice* description",
    "git_repo_root": "/Users/aaronmyatt/Development/waystation-vscode",
    "updated_at": "2025-12-06 10:06:57",
    "matchCount": 9
  },
  {
    "id": "d13ac1ce-8e1d-44cf-bc80-6f8302574f74",
    "name": "lint",
    "description": "",
    "git_repo_root": "/Users/aaronmyatt/Development/turbo",
    "updated_at": "2025-12-06 09:09:50",
    "matchCount": 3
  },
  {
    "id": "0760edfd-57ff-487f-9038-31465b901e02",
    "name": "Implement get_place_details LLM conversation tool call",
    "description": "When the LLM thinks it needs more details about a place we should fetch that info from the DB via PersistentGooglePlaces service, which will fetch from the db if it was cached already.\nThen we should respond to the LLM with the corresponding tool ID and the recent conversation context so that it can answer the users original query with more relevant information.",
    "git_repo_root": "/Users/aaronmyatt/Development/snappy-foodai",
    "updated_at": "2025-11-16T03:39:05.169Z",
    "matchCount": 4
  },
  {
    "id": "374b8986-d535-4cf5-a34f-f13b084b1477",
    "name": "Prompted Search",
    "description": "Our prompted search logic flow from user input submission to return the place results",
    "git_repo_root": "/Users/aaronmyatt/Development/snappy-foodai",
    "updated_at": "2025-11-16T03:39:05.169Z",
    "matchCount": 8
  },
  {
    "id": "5b5cdb2e-ac73-4f1f-994d-d97649f6bad8",
    "name": "Turbo Stream Broadcasts, how do they work?",
    "description": "From what I can tell the turbo_stream_from helper kicks off a whole lot of magical machinery that I want to de-mystify in this document. How do we go from this helper through to leveraging action cable to facilitate broadcasts after a model update.",
    "git_repo_root": "/Users/aaronmyatt/Development/turbo-rails",
    "updated_at": "2025-11-16T03:39:05.169Z",
    "matchCount": 3
  },
  {
    "id": "79985167-10a1-4826-b5e5-65ef44d36b81",
    "name": "Respond to get_place_photos tool call",
    "description": "",
    "git_repo_root": "/Users/aaronmyatt/Development/snappy-foodai",
    "updated_at": "2025-11-16T03:39:05.169Z",
    "matchCount": 5
  },
  {
    "id": "f8337f14-bd46-496b-a045-b785fb27b2b7",
    "name": "How does hx-boost work?",
    "description": "hx-boost claims to offer similar functionality to hotwire/turbo.",
    "git_repo_root": "/Users/aaronmyatt/Development/htmx",
    "updated_at": "2025-10-26T14:48:05.619Z",
    "matchCount": 14
  },
  {
    "id": "139fe288-f7fa-45be-b532-ce9f1174eb15",
    "name": "How does Turbo swap out pages dynamically?",
    "description": "After deciding that a click was worth hijacking, Turbo kicks into gear and actually fetches the HTML necessary to swap out the DOM body with whatever the servers spits out.",
    "git_repo_root": "/Users/aaronmyatt/Development/turbo",
    "updated_at": "2025-10-23T14:05:18.366Z",
    "matchCount": 22
  },
  {
    "id": "4f14aba8-9d87-4226-a62b-83c3552a5934",
    "name": "How does Turbo intercept link clicks?",
    "description": "Turbo listens for clicks on anchor tags and replaces them with a fetch call. How does it do that? Using events? Wrapping some sort of browser API? Catching the click/hover itself?",
    "git_repo_root": "/Users/aaronmyatt/Development/turbo",
    "updated_at": "2025-10-16T14:24:45.361Z",
    "matchCount": 9
  },
  {
    "id": "8a8c22b8-debd-427b-9710-08934142e921",
    "name": "wat",
    "description": "",
    "git_repo_root": "/Users/aaronmyatt/Development/atlas-web",
    "updated_at": "2025-10-16T14:24:45.361Z",
    "matchCount": 1
  },
  {
    "id": "5cf0671a-afc6-4c8f-95a2-8dde6bf8ae03",
    "name": "Deploy Dedicated Worker to Staging",
    "description": "Create a staging deployment for a dedicated worker by duplicating the existing backend task definition and reusing the same Docker image; extend the GitHub Actions workflow to deploy the new task, add a WORKER environment variable to toggle worker behavior, and conditionally enable report processing so only the worker instance handles jobs.",
    "git_repo_root": "/Users/aaronmyatt/Development/atlas-web",
    "updated_at": "2025-10-14T12:04:37.154Z",
    "matchCount": 4
  },
  {
    "id": "88c3f4cc-bff8-4c1b-9a3f-1ebb63676dbe",
    "name": "config",
    "description": "",
    "git_repo_root": "/Users/aaronmyatt/Development/atlas-web",
    "updated_at": "2025-10-14T12:04:37.154Z",
    "matchCount": 3
  }
  ],
  oneFlow: {
  "flow": {
    "id": "a04b3b6c-1d48-44bb-9ce4-2b955ef7b792",
    "name": "PR: new state management setup",
    "description": "A _very_ *nice* description",
    "git_repo_root": "/Users/aaronmyatt/Development/waystation-vscode",
    "git_commit_sha": "109367478c8ba38724670f52a027a245b0ec0ead",
    "git_branch": "copilot/simplify-local-state-management",
    "archived": 0,
    "created_at": "2025-12-06 09:46:19",
    "updated_at": "2025-12-06 10:06:57"
  },
  "matches": [
    {
      "flow_match_id": "264dff8a-f103-4c29-81cd-d98d33f9cd21",
      "match_id": "c77cf341be3f65837faa6961c7dc6bc8",
      "order_index": 0,
      "content_kind": "match",
      "match": {
        "line": "class FlowStateManager {",
        "file_path": "/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts",
        "repo_relative_file_path": "src/state/flowStateManager.ts",
        "file_name": "flowStateManager.ts",
        "line_no": 5,
        "grep_meta": "{\"line_number\":5,\"file_path\":\"/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts\",\"context_start_line\":1,\"context_end_line\":10,\"context_lines\":[\"import { FlowState, FlowListItem, MatchState } from './types';\",\"import { getDatabase, saveDatabase } from '../db-init';\",\"import { queryAsync, getAsync, runAsync } from '../db/dbAsync';\",\"\",\"class FlowStateManager {\",\"    private activeFlowState: FlowState | null = null;\",\"    private flowsListCache: FlowListItem[] | null = null;\",\"\",\"    // Read Operations\",\"    async loadFlowsList(filter?: { repoRoot?: string }): Promise<FlowListItem[]> {\"],\"matched_index_in_context\":4}",
        "git_repo_root": "aaronmyatt/waystation-vscode",
        "git_commit_sha": "109367478c8ba38724670f52a027a245b0ec0ead",
        "git_branch": "copilot/simplify-local-state-management"
      },
      "note": {
        "name": "FlowStateManager",
        "description": "We now have some indirection between the db and manipulating the state within it. Rather than writing changes directly to the WASM instance of Sqlite3, we first write it to a serializable, in-memory representation.\n\nA potential plan for this, other than making the state flows a little more intuitive, is to enable more convenient iteration on the underlying persistence technology, now we can more easily translate the in memory representation to any new schema or DB technology choice.\n\nThis should now also offer a natural point to issue automated syncing requests to the backend whenever the user is logged in."
      }
    },
    {
      "flow_match_id": "48232193-121f-4cc0-8963-5f24b8d79ce8",
      "match_id": "fdacae97b8c37c9756b009fff0b5585e",
      "order_index": 1,
      "content_kind": "match",
      "match": {
        "line": "    async loadFlowsList(filter?: { repoRoot?: string }): Promise<FlowListItem[]> {",
        "file_path": "/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts",
        "repo_relative_file_path": "src/state/flowStateManager.ts",
        "file_name": "flowStateManager.ts",
        "line_no": 10,
        "grep_meta": "{\"line_number\":10,\"file_path\":\"/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts\",\"context_start_line\":5,\"context_end_line\":15,\"context_lines\":[\"class FlowStateManager {\",\"    private activeFlowState: FlowState | null = null;\",\"    private flowsListCache: FlowListItem[] | null = null;\",\"\",\"    // Read Operations\",\"    async loadFlowsList(filter?: { repoRoot?: string }): Promise<FlowListItem[]> {\",\"        const db = getDatabase();\",\"        \",\"        const params: any[] = [];\",\"        let whereClause = 'WHERE f.archived = 0';\",\"        \"],\"matched_index_in_context\":5}",
        "git_repo_root": "aaronmyatt/waystation-vscode",
        "git_commit_sha": "109367478c8ba38724670f52a027a245b0ec0ead",
        "git_branch": "copilot/simplify-local-state-management"
      },
      "note": {
        "name": "Fetch and cache",
        "description": "Now we are fetching the minimal set of data needed to present the \"active\" state in the app - namely the list of \"flow\" titiles (for the sidepanel) an the active flows combined state to render the markdown preview."
      }
    },
    {
      "flow_match_id": "be59c868-c750-4fcf-b983-9bd1b5a88f9c",
      "match_id": "25200052de401a48d030809c8b22ca8c",
      "order_index": 2,
      "content_kind": "match",
      "match": {
        "line": "    async loadFlowState(flowId: string): Promise<FlowState | null> {",
        "file_path": "/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts",
        "repo_relative_file_path": "src/state/flowStateManager.ts",
        "file_name": "flowStateManager.ts",
        "line_no": 34,
        "grep_meta": "{\"line_number\":34,\"file_path\":\"/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts\",\"context_start_line\":29,\"context_end_line\":39,\"context_lines\":[\"        `;\",\"        this.flowsListCache = await queryAsync(db, sql, params);\",\"        return this.flowsListCache;\",\"    }\",\"\",\"    async loadFlowState(flowId: string): Promise<FlowState | null> {\",\"        const db = getDatabase();\",\"        \",\"        const flow = await getAsync(db, `\",\"            SELECT id, name, description, git_repo_root, git_commit_sha, git_branch,\",\"                   archived, created_at, updated_at\"],\"matched_index_in_context\":5}",
        "git_repo_root": "aaronmyatt/waystation-vscode",
        "git_commit_sha": "109367478c8ba38724670f52a027a245b0ec0ead",
        "git_branch": "copilot/simplify-local-state-management"
      }
    },
    {
      "flow_match_id": "b1729376-8eab-4b67-9db7-f6353528e492",
      "match_id": null,
      "order_index": 3,
      "content_kind": "note",
      "step_content": {
        "title": "Easier non-destructive change management",
        "body": "Now that we have a simple in-memory representation of the current state, we can more easily manipulate it. Non-destructive changes can first be done in memory, and later written to the db.",
        "file_path": null
      }
    },
    {
      "flow_match_id": "fe6e5450-661f-4881-b4da-30f8aa32f599",
      "match_id": "5c30808d-60c9-40cc-8f64-84eba76a17a2",
      "order_index": 4,
      "content_kind": "match",
      "match": {
        "line": "    private transformToMatchState(rows: any[]): MatchState[] {",
        "file_path": "/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts",
        "repo_relative_file_path": "src/state/flowStateManager.ts",
        "file_name": "flowStateManager.ts",
        "line_no": 246,
        "grep_meta": "{\"line_number\":246,\"file_path\":\"/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts\",\"selection_start_line\":246,\"selection_end_line\":273,\"selection_lines\":[\"    private transformToMatchState(rows: any[]): MatchState[] {\",\"        return rows.map(r => ({\",\"            flow_match_id: r.id,\",\"            match_id: r.matches_id,\",\"            order_index: r.order_index,\",\"            content_kind: r.content_kind,\",\"            match: r.file_path ? {\",\"                line: r.line,\",\"                file_path: r.file_path,\",\"                repo_relative_file_path: r.repo_relative_file_path,\",\"                file_name: r.file_name,\",\"                line_no: r.line_no,\",\"                grep_meta: r.grep_meta,\",\"                git_repo_root: r.git_repo_root,\",\"                git_commit_sha: r.git_commit_sha,\",\"                git_branch: r.git_branch\",\"            } : undefined,\",\"            note: (r.note_name || r.note_text) ? {\",\"                name: r.note_name,\",\"                description: r.note_text\",\"            } : undefined,\",\"            step_content: (r.step_content_title || r.step_content_body || r.step_content_file_path) ? {\",\"                title: r.step_content_title,\",\"                body: r.step_content_body,\",\"                file_path: r.step_content_file_path\",\"            } : undefined\",\"        }));\",\"    }\"],\"selection_text\":\"    private transformToMatchState(rows: any[]): MatchState[] {\\n        return rows.map(r => ({\\n            flow_match_id: r.id,\\n            match_id: r.matches_id,\\n            order_index: r.order_index,\\n            content_kind: r.content_kind,\\n            match: r.file_path ? {\\n                line: r.line,\\n                file_path: r.file_path,\\n                repo_relative_file_path: r.repo_relative_file_path,\\n                file_name: r.file_name,\\n                line_no: r.line_no,\\n                grep_meta: r.grep_meta,\\n                git_repo_root: r.git_repo_root,\\n                git_commit_sha: r.git_commit_sha,\\n                git_branch: r.git_branch\\n            } : undefined,\\n            note: (r.note_name || r.note_text) ? {\\n                name: r.note_name,\\n                description: r.note_text\\n            } : undefined,\\n            step_content: (r.step_content_title || r.step_content_body || r.step_content_file_path) ? {\\n                title: r.step_content_title,\\n                body: r.step_content_body,\\n                file_path: r.step_content_file_path\\n            } : undefined\\n        }));\\n    }\",\"matched_index_in_selection\":0,\"context_start_line\":246,\"context_end_line\":273,\"context_lines\":[\"    private transformToMatchState(rows: any[]): MatchState[] {\",\"        return rows.map(r => ({\",\"            flow_match_id: r.id,\",\"            match_id: r.matches_id,\",\"            order_index: r.order_index,\",\"            content_kind: r.content_kind,\",\"            match: r.file_path ? {\",\"                line: r.line,\",\"                file_path: r.file_path,\",\"                repo_relative_file_path: r.repo_relative_file_path,\",\"                file_name: r.file_name,\",\"                line_no: r.line_no,\",\"                grep_meta: r.grep_meta,\",\"                git_repo_root: r.git_repo_root,\",\"                git_commit_sha: r.git_commit_sha,\",\"                git_branch: r.git_branch\",\"            } : undefined,\",\"            note: (r.note_name || r.note_text) ? {\",\"                name: r.note_name,\",\"                description: r.note_text\",\"            } : undefined,\",\"            step_content: (r.step_content_title || r.step_content_body || r.step_content_file_path) ? {\",\"                title: r.step_content_title,\",\"                body: r.step_content_body,\",\"                file_path: r.step_content_file_path\",\"            } : undefined\",\"        }));\",\"    }\"],\"matched_index_in_context\":0,\"from_selection\":true}",
        "git_repo_root": "aaronmyatt/waystation-vscode",
        "git_commit_sha": "109367478c8ba38724670f52a027a245b0ec0ead",
        "git_branch": "copilot/simplify-local-state-management"
      },
      "note": {
        "name": "In-memory Schema",
        "description": ""
      }
    },
    {
      "flow_match_id": "f1fd3e39-0895-4b0a-aa6c-96b352844bbc",
      "match_id": "b4fe0e4b9f64a80150a6728b39beef9e",
      "order_index": 5,
      "content_kind": "match",
      "match": {
        "line": "    updateMatchNote(flowMatchId: string, name: string, description: string): void {",
        "file_path": "/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts",
        "repo_relative_file_path": "src/state/flowStateManager.ts",
        "file_name": "flowStateManager.ts",
        "line_no": 90,
        "grep_meta": "{\"line_number\":90,\"file_path\":\"/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts\",\"context_start_line\":85,\"context_end_line\":95,\"context_lines\":[\"            this.activeFlowState.flow.description = description;\",\"        }\",\"        this.activeFlowState.isDirty = true;\",\"    }\",\"\",\"    updateMatchNote(flowMatchId: string, name: string, description: string): void {\",\"        if (!this.activeFlowState) {\",\"            return;\",\"        }\",\"        const match = this.activeFlowState.matches.find(m => m.flow_match_id === flowMatchId);\",\"        if (match) {\"],\"matched_index_in_context\":5}",
        "git_repo_root": "aaronmyatt/waystation-vscode",
        "git_commit_sha": "109367478c8ba38724670f52a027a245b0ec0ead",
        "git_branch": "copilot/simplify-local-state-management"
      }
    },
    {
      "flow_match_id": "3a7c85b0-ab2d-4d8c-9720-a133499e07b8",
      "match_id": "07ca21358a00580c460f93e35e147f7a",
      "order_index": 6,
      "content_kind": "match",
      "match": {
        "line": "    reorderMatch(flowMatchId: string, newIndex: number): void {",
        "file_path": "/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts",
        "repo_relative_file_path": "src/state/flowStateManager.ts",
        "file_name": "flowStateManager.ts",
        "line_no": 116,
        "grep_meta": "{\"line_number\":116,\"file_path\":\"/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts\",\"context_start_line\":111,\"context_end_line\":121,\"context_lines\":[\"            match.step_content.body = body;\",\"            this.activeFlowState.isDirty = true;\",\"        }\",\"    }\",\"\",\"    reorderMatch(flowMatchId: string, newIndex: number): void {\",\"        if (!this.activeFlowState) {\",\"            return;\",\"        }\",\"        const matches = this.activeFlowState.matches;\",\"        const currentIndex = matches.findIndex(m => m.flow_match_id === flowMatchId);\"],\"matched_index_in_context\":5}",
        "git_repo_root": "aaronmyatt/waystation-vscode",
        "git_commit_sha": "109367478c8ba38724670f52a027a245b0ec0ead",
        "git_branch": "copilot/simplify-local-state-management"
      }
    },
    {
      "flow_match_id": "7bbaa53a-87a0-42f6-b3fd-43db948f8734",
      "match_id": "d85052bef914e4296a7cf0d778c32ed8",
      "order_index": 7,
      "content_kind": "match",
      "match": {
        "line": "        await runAsync(db, `",
        "file_path": "/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts",
        "repo_relative_file_path": "src/state/flowStateManager.ts",
        "file_name": "flowStateManager.ts",
        "line_no": 201,
        "grep_meta": "{\"line_number\":201,\"file_path\":\"/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts\",\"selection_start_line\":193,\"selection_end_line\":201,\"selection_lines\":[\"    async persist(): Promise<void> {\",\"        if (!this.activeFlowState || !this.activeFlowState.isDirty) {\",\"            return;\",\"        }\",\"        \",\"        const db = getDatabase();\",\"        const { flow, matches } = this.activeFlowState;\",\"        \",\"        await runAsync(db, `\"],\"selection_text\":\"async persist(): Promise<void> {\\n        if (!this.activeFlowState || !this.activeFlowState.isDirty) {\\n            return;\\n        }\\n        \\n        const db = getDatabase();\\n        const { flow, matches } = this.activeFlowState;\\n        \\n        await runAsync(db, `\",\"matched_index_in_selection\":8,\"context_start_line\":193,\"context_end_line\":201,\"context_lines\":[\"    async persist(): Promise<void> {\",\"        if (!this.activeFlowState || !this.activeFlowState.isDirty) {\",\"            return;\",\"        }\",\"        \",\"        const db = getDatabase();\",\"        const { flow, matches } = this.activeFlowState;\",\"        \",\"        await runAsync(db, `\"],\"matched_index_in_context\":8,\"from_selection\":true}",
        "git_repo_root": "aaronmyatt/waystation-vscode",
        "git_commit_sha": "109367478c8ba38724670f52a027a245b0ec0ead",
        "git_branch": "copilot/simplify-local-state-management"
      },
      "note": {
        "name": "Opt in persistence",
        "description": "Explicitly write out changes to the db when needed."
      }
    },
    {
      "flow_match_id": "f04d61bb-0c4e-4ba2-a4c6-864551317025",
      "match_id": "dc4d3a60af5078091f7f2d4d25a42077",
      "order_index": 8,
      "content_kind": "match",
      "match": {
        "line": "    async deleteFlowMatch(flowMatchId: string): Promise<void> {",
        "file_path": "/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts",
        "repo_relative_file_path": "src/state/flowStateManager.ts",
        "file_name": "flowStateManager.ts",
        "line_no": 150,
        "grep_meta": "{\"line_number\":150,\"file_path\":\"/Users/aaronmyatt/Development/waystation-vscode/src/state/flowStateManager.ts\",\"context_start_line\":145,\"context_end_line\":155,\"context_lines\":[\"            matches.forEach((m, i) => m.order_index = i);\",\"            this.activeFlowState.isDirty = true;\",\"        }\",\"    }\",\"\",\"    async deleteFlowMatch(flowMatchId: string): Promise<void> {\",\"        console.log(`[FlowStateManager] Deleting flow match id: ${flowMatchId}`);\",\"        const db = getDatabase();\",\"        \",\"        // Get flows_id and order_index before deletion\",\"        const current = await getAsync(db, \"],\"matched_index_in_context\":5}",
        "git_repo_root": "aaronmyatt/waystation-vscode",
        "git_commit_sha": "109367478c8ba38724670f52a027a245b0ec0ead",
        "git_branch": "copilot/simplify-local-state-management"
      },
      "note": {
        "name": "The only exception",
        "description": "FlowMatch changes are destructive, we need to handle them immediately so we can recompute the order of steps correctly."
      }
    }
  ],
  "isDirty": false
  }
};

window.addEventListener('ws::action::requestFlow', (e) => {
  console.log('Received ws::action::requestFlow event:', e.detail);
  setTimeout(() => {
    globalThis.flowService.load(window.__INITIAL_DATA__.oneFlow);
  }, 1500); // Simulate async delay
});

window.addEventListener('ws::flow::updated', (e) => {
  console.log('Received ws::flow::requestFlow event:', e.detail);
  if(!e.detail.flow.id){
    e.detail.flow.id = 'a04b3b6c-1d48-44bb-9ce4-2b955ef7b792';
    setTimeout(() => {
      globalThis.flowService.load(e.detail);
    }, 150); // Simulate async delay
  }
});
</script>
<script src="dist/waystation-vscode.js"></script>

<!-- Development Event Log Panel -->
<div id="ws-dev-log" style="position: fixed; bottom: 0; right: 0; width: 400px; max-height: 50vh; background: #1a1a1a; border: 1px solid #333; border-radius: 8px 8px 0 0; font-family: monospace; font-size: 12px; z-index: 10000; display: flex; flex-direction: column; box-shadow: 0 -2px 10px rgba(0,0,0,0.3);">
  <div id="ws-log-header" style="padding: 8px 12px; background: #2a2a2a; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none;">
    <span style="color: #4CAF50; font-weight: bold;">üîç WS Dev Events (<span id="ws-log-count">0</span>)</span>
    <div style="display: flex; gap: 8px;">
      <button id="ws-log-clear" style="padding: 2px 8px; background: #444; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">Clear</button>
      <button id="ws-log-copy" style="padding: 2px 8px; background: #444; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">Copy</button>
      <span id="ws-log-toggle" style="color: #888; font-size: 16px;">‚ñº</span>
    </div>
  </div>
  <div id="ws-log-content" style="overflow-y: auto; padding: 8px; color: #e0e0e0; flex: 1; display: block;">
    <div style="color: #888; font-style: italic;">Listening for ws:: events...</div>
  </div>
</div>

<script>
(function() {
  const logPanel = document.getElementById('ws-dev-log');
  const logContent = document.getElementById('ws-log-content');
  const logCount = document.getElementById('ws-log-count');
  const logHeader = document.getElementById('ws-log-header');
  const logToggle = document.getElementById('ws-log-toggle');
  const clearBtn = document.getElementById('ws-log-clear');
  const copyBtn = document.getElementById('ws-log-copy');
  
  let eventCount = 0;
  let allLogs = [];
  let isCollapsed = false;

  // Auto-scroll helper
  function shouldAutoScroll() {
    const { scrollTop, scrollHeight, clientHeight } = logContent;
    return scrollHeight - scrollTop - clientHeight < 50;
  }

  function logEvent(eventType, eventName, detail) {
    const autoScroll = shouldAutoScroll();
    const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });
    
    eventCount++;
    logCount.textContent = eventCount;

    const entryDiv = document.createElement('div');
    entryDiv.style.cssText = 'margin-bottom: 8px; padding: 6px; background: #252525; border-left: 3px solid #4CAF50; border-radius: 3px;';
    
    const header = document.createElement('div');
    header.style.cssText = 'color: #4CAF50; font-weight: bold; margin-bottom: 4px;';
    header.textContent = `[${timestamp}] ${eventName}`;
    
    const typeLabel = document.createElement('span');
    typeLabel.style.cssText = 'margin-left: 8px; padding: 2px 6px; background: #333; border-radius: 3px; font-size: 10px; color: #888;';
    typeLabel.textContent = eventType;
    header.appendChild(typeLabel);
    
    entryDiv.appendChild(header);

    if (detail !== undefined && detail !== null) {
      const detailDiv = document.createElement('div');
      detailDiv.style.cssText = 'color: #aaa; white-space: pre-wrap; word-break: break-all; max-height: 200px; overflow-y: auto; font-size: 11px; margin-top: 4px; padding: 4px; background: #1a1a1a; border-radius: 2px;';
      try {
        detailDiv.textContent = typeof detail === 'object' ? JSON.stringify(detail, null, 2) : String(detail);
      } catch (e) {
        detailDiv.textContent = '[Circular or non-serializable data]';
      }
      entryDiv.appendChild(detailDiv);
    }

    // Store for copy functionality
    allLogs.push({
      timestamp,
      eventName,
      eventType,
      detail
    });

    logContent.appendChild(entryDiv);

    // Auto-scroll if user was near bottom
    if (autoScroll) {
      logContent.scrollTop = logContent.scrollHeight;
    }
  }

  // Listen for all CustomEvents with ws:: prefix
  window.addEventListener('*', function(e) {
    if (e.type && e.type.startsWith('ws::')) {
      logEvent('CustomEvent', e.type, e.detail);
    }
  }, true);

  // Alternative: Listen for specific event types by overriding dispatchEvent
  const originalDispatch = EventTarget.prototype.dispatchEvent;
  EventTarget.prototype.dispatchEvent = function(event) {
    if (event.type && event.type.startsWith('ws::')) {
      logEvent('CustomEvent', event.type, event instanceof CustomEvent ? event.detail : null);
    }
    return originalDispatch.call(this, event);
  };

  // Listen for postMessage events with ws:: prefix
  window.addEventListener('message', function(e) {
    if (typeof e.data === 'string' && e.data.startsWith('ws::')) {
      logEvent('postMessage', e.data, null);
    } else if (e.data && typeof e.data === 'object' && e.data.type && e.data.type.startsWith('ws::')) {
      logEvent('postMessage', e.data.type, e.data.payload || e.data);
    }
  });

  // Toggle collapse
  logHeader.addEventListener('click', function(e) {
    if (e.target === clearBtn || e.target === copyBtn) return;
    
    isCollapsed = !isCollapsed;
    logContent.style.display = isCollapsed ? 'none' : 'block';
    logToggle.textContent = isCollapsed ? '‚ñ≤' : '‚ñº';
  });

  // Clear logs
  clearBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    logContent.innerHTML = '<div style="color: #888; font-style: italic;">Listening for ws:: events...</div>';
    eventCount = 0;
    allLogs = [];
    logCount.textContent = '0';
  });

  // Copy logs to clipboard
  copyBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    const logText = allLogs.map(log => {
      return `[${log.timestamp}] ${log.eventName} (${log.eventType})\n${
        log.detail ? (typeof log.detail === 'object' ? JSON.stringify(log.detail, null, 2) : log.detail) : ''
      }`;
    }).join('\n\n---\n\n');
    
    navigator.clipboard.writeText(logText).then(() => {
      const originalText = copyBtn.textContent;
      copyBtn.textContent = '‚úì Copied';
      copyBtn.style.background = '#4CAF50';
      setTimeout(() => {
        copyBtn.textContent = originalText;
        copyBtn.style.background = '#444';
      }, 1500);
    });
  });

  // Test mode: Add ?ws-test=true to URL to emit test events
  if (window.location.search.includes('ws-test=true')) {
    setTimeout(() => {
      console.log('[WS Dev Log] Test mode enabled - emitting test events');
      window.dispatchEvent(new CustomEvent('ws::test:init', { detail: { status: 'ready' } }));
      
      setTimeout(() => {
        window.dispatchEvent(new CustomEvent('ws::action:editFlow', { detail: { flowId: 'test-123', name: 'Test Flow' } }));
      }, 1000);
      
      setTimeout(() => {
        window.dispatchEvent(new CustomEvent('ws::flow:updated', { detail: { id: 'test-123', changes: ['name', 'description'] } }));
      }, 2000);
    }, 500);
  }
})();
</script>
</body>
</html>